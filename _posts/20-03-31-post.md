---
title:  "문제풀이 정리 (~3/31)"
excerpt: "2/29~3/31 알고리즘 문제풀이 정리"

categories:
  - Algorithm
tags:
  - Algorithm
  - cpp
last_modified_at: 2020-3-31 T17:30:00-05:00
toc: true
toc_sticky: true
doc-font-size: 10px;
---

#### 1002_A.cpp
***
 n이 주어졌을 때  
 n      n-1  
 n-3    n-2  
 n-4    n -5  
…                 이와 같이 지그재그로 나눠준다면 규칙을 찾을 수 있다


#### 1106_A.cpp
***
2차원벡터와 반복자를 사용하고 greedy로 해결가능.
2차원 벡터 시간되면 정리하자.

#### 1106_C.cpp
***
(a+b)^2 은 a^2+b^2 + 2ab이므로, 두개 씩 짝지어질 때, a*b의 값이 최소가 되면 된다.
 모든 a*b값이 최소가 됨을 보장하려면, 정렬 후 앞에서 a 뒤에서 b를 가져오면 된다. 
그러나 이것이 완벽한 풀이인지는 모르겠다. 

#### 1007_A.cpp
***
string의 Substr(pos, npos)함수는 pos 는 substring 의 시작값.
mpos 는 substring 의 사이즈를 의미한다. npos부분을 생략할 시 pos부터 문자열의 끝까지 리턴한다.
만약 pos+ npos의 크기가 string 보다 큰 경우에는 pos이후로 문자열의 끝까지 리턴한다


#### 1110_A.cpp
***
계산하기에는 수의 범위가 너무 크기에 수학적으로 접근했다. B가 짝수인경우 마지막 수에서 홀 짝이 갈리고, 홀수인 경우에는 K의 자릿수중 홀수를 세어주면 된다.

#### 1111_A.cpp
***
```cpp
if(arphabet[s[i]-'a'] != arphabet[t[i]-'a'])return printf("no")*0;
```
반복문에서 출력과 동시에 종료하고싶으면, return printf(“no”)*0;으로 종료가능.

#### 1117_B.cpp
***
```cpp
(emotes[n-1] * k + emotes[n-2] ) * (m/(k+1)) + m%(k+1)*emotes[n-1];
(emotes[n-1] * k + emotes[n-2] ) * m/(k+1) + m%(k+1)*emotes[n-1];
```
위의 두식은 다른결과를 내보낸다. 당연한 부분인데 헤맸다. /연산이나 %연산이 있는경우, 연산자 우선순위를 신경쓰자. 혹은 괄호로 묶어 해결해주자.

